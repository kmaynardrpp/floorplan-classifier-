/**
 * Point represents a 2D coordinate on the canvas
 */
export interface Point {
  x: number
  y: number
}

/**
 * Predefined zone types from the spec
 * Includes original types plus new agentic analysis types
 */
export const PREDEFINED_ZONE_TYPES = [
  // Original types
  'aisle',
  'travel_lane',
  'parking_lot',
  'open_floor',
  'loading_dock',
  'intersection',
  'restricted',
  'pick_area',
  'drop_area',
  'staging_area',
  'charging_station',
  'hazard_zone',
  // New agentic analysis types
  'aisle_path', // Travelable path between racking (distinct from general 'aisle')
  'racking', // Physical shelving units (non-travelable)
  'racking_area', // Parent zone containing racking + aisles (for subdivision)
  'conveyor_area', // Conveyor equipment zones (non-travelable)
  'docking_area', // Loading dock bays (alias for loading_dock, non-travelable)
  'administrative', // Office/admin areas (non-travelable)
  'storage_floor', // Bulk storage cells (non-travelable)
  // AI-detected blocked areas within 2D coverage
  'blocked_area', // Non-travelable obstacles detected by AI (conveyors, barriers, etc.)
] as const

export type PredefinedZoneType = (typeof PREDEFINED_ZONE_TYPES)[number]

/**
 * Zone types that are travelable for routing purposes
 * These zones represent areas where forklifts and workers can travel
 */
export const TRAVELABLE_ZONE_TYPES = [
  'travel_lane',
  'aisle_path',
  'parking_lot',
] as const

export type TravelableZoneType = (typeof TRAVELABLE_ZONE_TYPES)[number]

/**
 * Check if a zone type is travelable for routing
 * Note: 'aisle' and 'open_floor' are context-dependent and NOT automatically travelable
 * @param zoneType - The zone type to check
 * @returns true if the zone type is travelable
 */
export function isTravelable(zoneType: string): boolean {
  return (TRAVELABLE_ZONE_TYPES as readonly string[]).includes(zoneType)
}

/**
 * Zone type can be predefined or custom (string)
 */
export type ZoneType = PredefinedZoneType | string

/**
 * Zone metadata containing visual and custom properties
 */
export interface ZoneMetadata {
  /** Custom color override (null = use type default) */
  color: string | null
  /** Opacity 0-1, default 0.5 */
  opacity: number
  /** Whether the zone is visible on canvas */
  isVisible: boolean
  /** Whether the zone is locked from editing */
  isLocked: boolean
  /** User description of the zone */
  description: string
  /** User-defined key-value properties */
  customProperties: Record<string, string>
}

/**
 * Zone source types
 * - ai: Generated by AI analysis
 * - manual: Created manually by user
 * - tdoa: Generated from TDOA anchor pairs (1D pairs)
 * - coverage: Generated from coverage polygons
 * - imported: Imported from zones.json file
 */
export type ZoneSource = 'ai' | 'manual' | 'tdoa' | 'coverage' | 'imported'

/**
 * Zone represents a detected or manually created region on the floorplan
 */
export interface Zone {
  /** Unique identifier (UUID) */
  id: string
  /** Display name of the zone */
  name: string
  /** Zone classification type */
  type: ZoneType
  /** Polygon vertices defining the zone boundary */
  vertices: Point[]
  /** AI confidence score (null for manual zones) */
  confidence: number | null
  /** Source of the zone */
  source: ZoneSource
  /** Zone metadata */
  metadata: ZoneMetadata
  /** Creation timestamp (ISO 8601) */
  createdAt: string
  /** Last update timestamp (ISO 8601) */
  updatedAt: string
}

/**
 * Check if a zone was generated programmatically (from TDOA or coverage data)
 * @param zone - The zone to check
 * @returns true if the zone source is 'tdoa' or 'coverage'
 */
export function isProgrammaticZone(zone: Zone): boolean {
  return zone.source === 'tdoa' || zone.source === 'coverage'
}

/**
 * Check if a zone was imported from zones.json
 * @param zone - The zone to check
 * @returns true if the zone source is 'imported'
 */
export function isImportedZone(zone: Zone): boolean {
  return zone.source === 'imported'
}

/**
 * Custom zone type definition
 */
export interface CustomZoneType {
  id: string
  /** Unique identifier (snake_case) */
  name: string
  /** Display label */
  label: string
  /** Hex color code */
  color: string
  /** Description of the zone type */
  description: string
}

/**
 * Default metadata for new zones
 */
export const DEFAULT_ZONE_METADATA: ZoneMetadata = {
  color: null,
  opacity: 0.5,
  isVisible: true,
  isLocked: false,
  description: '',
  customProperties: {},
}

/**
 * Create a new zone with defaults
 */
export function createZone(
  partial: Partial<Zone> & Pick<Zone, 'id' | 'name' | 'type' | 'vertices'>
): Zone {
  const now = new Date().toISOString()
  return {
    confidence: null,
    source: 'manual',
    metadata: { ...DEFAULT_ZONE_METADATA },
    createdAt: now,
    updatedAt: now,
    ...partial,
  }
}

// =============================================================================
// Agentic Analysis Types
// =============================================================================

/**
 * Bounding box for a region of the image
 */
export interface BoundingBox {
  /** X coordinate of top-left corner */
  x: number
  /** Y coordinate of top-left corner */
  y: number
  /** Width of the bounding box */
  width: number
  /** Height of the bounding box */
  height: number
}

/**
 * Zone types used in coarse (first-pass) detection
 */
export const COARSE_ZONE_TYPES = [
  'travel_lane',
  'racking_area',
  'parking_lot',
  'conveyor_area',
  'docking_area',
  'administrative',
  'storage_floor',
  'open_floor',
] as const

export type CoarseZoneType = (typeof COARSE_ZONE_TYPES)[number]

/**
 * Coarse zone from main agent detection (Phase 1)
 * These zones may be subdivided by sub-agents
 */
export interface CoarseZone {
  /** Unique identifier */
  id: string
  /** Display name */
  name: string
  /** Zone classification type */
  type: CoarseZoneType
  /** Polygon vertices */
  vertices: Point[]
  /** AI confidence score (0-1) */
  confidence: number
  /** Whether this zone needs sub-agent subdivision */
  needsSubdivision: boolean
  /** Bounding box for cropping */
  boundingBox: BoundingBox
}

/**
 * Input for sub-agent analysis (Phase 2)
 */
export interface SubAgentInput {
  /** Cropped image data URL (just the racking_area region) */
  croppedImageDataUrl: string
  /** Width of the cropped region in pixels */
  cropWidth: number
  /** Height of the cropped region in pixels */
  cropHeight: number
  /** Offset from original image origin for coordinate mapping */
  originalOffset: Point
  /** Parent zone ID for linking results */
  parentZoneId: string
}

/**
 * Zone subdivision from sub-agent (aisle_path or racking)
 */
export interface SubdividedZone {
  /** Zone type: aisle_path (travelable) or racking (non-travelable) */
  type: 'aisle_path' | 'racking'
  /** Display name */
  name: string
  /** Polygon vertices (relative to cropped image) */
  vertices: Point[]
  /** AI confidence score (0-1) */
  confidence: number
  /** Whether this zone is travelable */
  travelable: boolean
}

/**
 * Output from sub-agent analysis
 */
export interface SubAgentOutput {
  /** Dominant direction of racking lines in this zone */
  direction: 'horizontal' | 'vertical'
  /** Subdivided zones within the racking area */
  subdivisions: SubdividedZone[]
  /** Optional analysis notes from the AI */
  analysisNotes?: string
}

/**
 * Validation result for sub-agent output
 */
export interface ValidationResult {
  /** Whether the output is valid */
  valid: boolean
  /** Critical errors that invalidate the output */
  errors: string[]
  /** Non-critical warnings */
  warnings: string[]
}
